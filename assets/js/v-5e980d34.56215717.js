"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[7288],{1206:(e,i,a)=>{a.r(i),a.d(i,{data:()=>t});const t={key:"v-5e980d34",path:"/tools/git.html",title:"Git学习",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"配置",slug:"配置",children:[]},{level:2,title:"多账号",slug:"多账号",children:[]},{level:2,title:"理论",slug:"理论",children:[{level:3,title:"三棵树",slug:"三棵树",children:[]},{level:3,title:"Git工作流程",slug:"git工作流程",children:[]},{level:3,title:"Git管理文件的三种状态",slug:"git管理文件的三种状态",children:[]}]},{level:2,title:"操作",slug:"操作",children:[{level:3,title:"基础操作流程",slug:"基础操作流程",children:[]},{level:3,title:"查看状态 git status",slug:"查看状态-git-status",children:[]},{level:3,title:"撤销修改  get checkout -- file",slug:"撤销修改-get-checkout-file",children:[]},{level:3,title:"查看历史提交 git log",slug:"查看历史提交-git-log",children:[]},{level:3,title:"查看commit提交历史",slug:"查看commit提交历史",children:[]}]},{level:2,title:"回到过去git reset",slug:"回到过去git-reset",children:[{level:3,title:"git reset --mixed HEAD~",slug:"git-reset-mixed-head",children:[]},{level:3,title:"git reset --soft HEAD~",slug:"git-reset-soft-head",children:[]},{level:3,title:"git reset --hard HEAD~",slug:"git-reset-hard-head",children:[]},{level:3,title:"回滚或前滚指定快照（hash）",slug:"回滚或前滚指定快照-hash",children:[]},{level:3,title:"回滚个别文件",slug:"回滚个别文件",children:[]}]},{level:2,title:"版本对比",slug:"版本对比",children:[{level:3,title:"命令记录",slug:"命令记录",children:[]},{level:3,title:"git diff",slug:"git-diff",children:[]},{level:3,title:"LINUX命令",slug:"linux命令",children:[]},{level:3,title:"对比两个快照的差异",slug:"对比两个快照的差异",children:[]},{level:3,title:"比较当前工作目录和Git仓库",slug:"比较当前工作目录和git仓库",children:[]},{level:3,title:"比较最新快照和当前目录",slug:"比较最新快照和当前目录",children:[]},{level:3,title:"比较暂存区和Git仓库",slug:"比较暂存区和git仓库",children:[]},{level:3,title:"比较暂存区和Git仓库的快照ID",slug:"比较暂存区和git仓库的快照id",children:[]}]},{level:2,title:"小技巧",slug:"小技巧",children:[{level:3,title:"1.修改最后一次提交  --amend",slug:"_1-修改最后一次提交-amend",children:[]},{level:3,title:"2.删除文件  rm",slug:"_2-删除文件-rm",children:[]},{level:3,title:"3.重命名文件  mv",slug:"_3-重命名文件-mv",children:[]}]},{level:2,title:"Git分支",slug:"git分支",children:[{level:3,title:"创建分支 git branch name",slug:"创建分支-git-branch-name",children:[]},{level:3,title:"切换分支 git checkout name",slug:"切换分支-git-checkout-name",children:[]},{level:3,title:"创建并切换分支",slug:"创建并切换分支",children:[]},{level:3,title:"合并分支 git merge",slug:"合并分支-git-merge",children:[]},{level:3,title:"删除分支 git branch -d name",slug:"删除分支-git-branch-d-name",children:[]},{level:3,title:"Fast forward",slug:"fast-forward",children:[]},{level:3,title:"小结",slug:"小结",children:[]},{level:3,title:"分支策略",slug:"分支策略",children:[]},{level:3,title:"分支储藏",slug:"分支储藏",children:[]},{level:3,title:"匿名分支",slug:"匿名分支",children:[]},{level:3,title:"git checkout",slug:"git-checkout",children:[]},{level:3,title:"恢复文件",slug:"恢复文件",children:[]},{level:3,title:"恢复快照",slug:"恢复快照",children:[]},{level:3,title:"reset和checkout的区别",slug:"reset和checkout的区别",children:[]}]},{level:2,title:"远程仓库",slug:"远程仓库",children:[{level:3,title:"添加远程库",slug:"添加远程库",children:[]},{level:3,title:"从远程库克隆",slug:"从远程库克隆",children:[]},{level:3,title:"查看远程仓库信息",slug:"查看远程仓库信息",children:[]},{level:3,title:"推送分支",slug:"推送分支",children:[]}]},{level:2,title:"多人协作",slug:"多人协作",children:[{level:3,title:"创建远程origin的dev分支到本地",slug:"创建远程origin的dev分支到本地",children:[]},{level:3,title:"冲突解决",slug:"冲突解决",children:[]},{level:3,title:"git pull失败",slug:"git-pull失败",children:[]},{level:3,title:"小结",slug:"小结-1",children:[]},{level:3,title:"Rebase",slug:"rebase",children:[]}]},{level:2,title:"标签管理",slug:"标签管理",children:[{level:3,title:"创建标签",slug:"创建标签",children:[]},{level:3,title:"操作标签",slug:"操作标签",children:[]}]}],filePathRelative:"tools/git.md",git:{updatedTime:16495249e5,contributors:[{name:"Jerry Chen",email:"caffreygo@163.com",commits:1}]}}},7803:(e,i,a)=>{a.r(i),a.d(i,{default:()=>d});const t=(0,a(6252).uE)('<h1 id="git学习" tabindex="-1"><a class="header-anchor" href="#git学习" aria-hidden="true">#</a> Git学习</h1><h2 id="配置" tabindex="-1"><a class="header-anchor" href="#配置" aria-hidden="true">#</a> 配置</h2><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">git</span> config --global user.name <span class="token string">&quot;username&quot;</span>\n\n<span class="token function">git</span> config --global user.email <span class="token string">&quot;userEmail&quot;</span>\n\n<span class="token function">git</span> config --list    查看所有配置\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="多账号" tabindex="-1"><a class="header-anchor" href="#多账号" aria-hidden="true">#</a> 多账号</h2><p><img src="https://raw.githubusercontent.com/caffreygo/static/main/blog/git/acount.png" alt=""></p><p>config内容：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 个人账号</span>\nHost jinrui\nHostName github.com\nUser <span class="token function">git</span>\nIdentityFile ~/.ssh/id_rsa\n\n<span class="token comment"># 公司账号</span>\nHost kooboo\nHostName github.com\nUser <span class="token function">git</span>\nIdentityFile ~/.ssh/kooboo\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="理论" tabindex="-1"><a class="header-anchor" href="#理论" aria-hidden="true">#</a> 理论</h2><h3 id="三棵树" tabindex="-1"><a class="header-anchor" href="#三棵树" aria-hidden="true">#</a> 三棵树</h3><p>​ 工作区域/目录 working Directory、暂存区域 stage(index) 和Git仓库 Repository(HEAD)</p><h3 id="git工作流程" tabindex="-1"><a class="header-anchor" href="#git工作流程" aria-hidden="true">#</a> Git工作流程</h3><ul><li><p>在工作目录中添加，修改文件 (Working directory) 工作区</p></li><li><p>将需要进行版本管理的文件放入暂存区域 (Stage) 暂存区</p></li><li><p>将暂存区域的文件提交到Git仓库 (Repository) 仓库</p></li></ul><h3 id="git管理文件的三种状态" tabindex="-1"><a class="header-anchor" href="#git管理文件的三种状态" aria-hidden="true">#</a> Git管理文件的三种状态</h3><ul><li>已修改 （modified）</li><li>已暂存（staged）</li><li>已提交（committed）</li></ul><h2 id="操作" tabindex="-1"><a class="header-anchor" href="#操作" aria-hidden="true">#</a> 操作</h2><h3 id="基础操作流程" tabindex="-1"><a class="header-anchor" href="#基础操作流程" aria-hidden="true">#</a> 基础操作流程</h3><p>​ <code> git init</code> 生成隐藏的 .git文件夹(切勿改动！)</p><p>​ <code>git add file</code> 添加文件到暂存区域</p><p>​ <code>git commit -m &quot;add what&quot;</code> 暂存区域的文件添加到Git仓库</p><p>（git commit -am &quot;添加到暂存区并提交&quot;）</p><h3 id="查看状态-git-status" tabindex="-1"><a class="header-anchor" href="#查看状态-git-status" aria-hidden="true">#</a> 查看状态 git status</h3><ul><li><p>(Untracked files 未跟踪的文件：未添加到暂存区或者Git仓库)</p></li><li><p>(Change to be committed 添加到暂存区，但是未commit到仓库)</p><h4 id="git-reset-head-file" tabindex="-1"><a class="header-anchor" href="#git-reset-head-file" aria-hidden="true">#</a> <code>git reset HEAD -- file</code></h4><p>清空add命令向暂存区提交的关于file文件的修改（stage）；这个命令仅改变<strong>暂存区</strong>，并不改变工作区</p><p>HEAD指向commit最新的那个版本</p><p>该操作不影响工作区 (撤销 git add 操作)</p></li><li><p>(Changes not staged for commit 已修改的文件modified未添加到暂存区staged)</p><h4 id="git-checkout-file" tabindex="-1"><a class="header-anchor" href="#git-checkout-file" aria-hidden="true">#</a> <code>git checkout -- file</code></h4><p>eg. git checkout -- LICENSE (--空格file)</p><p>将修改的文件<strong>丢弃工作区的更改</strong> (<em>danger</em> <em>operation</em>)</p></li><li><p>(Changes not staged for commit AND Change to be committed )</p><p>工作区有一个版本未添加到暂存区，暂存区也有一个版本为提交到仓库</p><p>可以git add将工作区的版本覆盖到暂存区，然后提交</p><p>也可以丢弃工作区的更改git checkout -- file, 然后只提交暂存区的版本到仓库</p></li></ul><h3 id="撤销修改-get-checkout-file" tabindex="-1"><a class="header-anchor" href="#撤销修改-get-checkout-file" aria-hidden="true">#</a> 撤销修改 get checkout -- file</h3><p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><h3 id="查看历史提交-git-log" tabindex="-1"><a class="header-anchor" href="#查看历史提交-git-log" aria-hidden="true">#</a> 查看历史提交 git log</h3><p>​ 查看git commit的历史和提交的说明</p><p>​ 草黄色 commit id 唯一的id对应其版本</p><h3 id="查看commit提交历史" tabindex="-1"><a class="header-anchor" href="#查看commit提交历史" aria-hidden="true">#</a> 查看commit提交历史</h3><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git log --pretty=oneline --abbrev-commit\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h2 id="回到过去git-reset" tabindex="-1"><a class="header-anchor" href="#回到过去git-reset" aria-hidden="true">#</a> 回到过去git reset</h2><p>git reset HEAD -- file</p><h3 id="git-reset-mixed-head" tabindex="-1"><a class="header-anchor" href="#git-reset-mixed-head" aria-hidden="true">#</a> git reset --mixed HEAD~</h3><p><code>git reset HEAD~</code> Repository(仓库)回溯一个版本(mixed默认)</p><p><code>git reset HEAD~num</code> num 为前num个快照</p><ul><li>移动HEAD的指向，将其指向上一个快照（第三棵树，repository）</li><li>将HEAD移动后指向的快照回滚到暂存区域（第二棵树，staged）</li></ul><p>Repository(仓库)的HEAD指向前一个版本，并且此时暂存区和仓库也回到之前那个版本</p><p>此时git status显示changes not staged for commit，工作区文件还在最新版本未暂存</p><h3 id="git-reset-soft-head" tabindex="-1"><a class="header-anchor" href="#git-reset-soft-head" aria-hidden="true">#</a> git reset --soft HEAD~</h3><ul><li>移动HEAD的指向，将其指向上一个快照（第三棵树，repository）</li></ul><p>即只修改仓库，撤销上一次commit的提交，工作区和暂存区不变</p><h3 id="git-reset-hard-head" tabindex="-1"><a class="header-anchor" href="#git-reset-hard-head" aria-hidden="true">#</a> git reset --hard HEAD~</h3><ul><li>移动HEAD的指向，将其指向上一个快照（第三棵树，repository）</li><li>将HEAD移动后指向的快照回滚到暂存区域（第二棵树，stage）</li><li>将暂存区域的文件还原到工作目录（第一棵树，Working directory）</li></ul><h3 id="回滚或前滚指定快照-hash" tabindex="-1"><a class="header-anchor" href="#回滚或前滚指定快照-hash" aria-hidden="true">#</a> 回滚或前滚指定快照（hash）</h3><p>(hash很长，一般指定前五个就能找到确定快照了)</p><p><code>git reset abcde</code></p><p><code>git reset --hard hash</code> 前滚（默认mixed, hard能将删除的东西在工作目录恢复）</p><h3 id="回滚个别文件" tabindex="-1"><a class="header-anchor" href="#回滚个别文件" aria-hidden="true">#</a> 回滚个别文件</h3><p>git reset 版本快照 文件名/路径 （HEAD不会改变）</p><h2 id="版本对比" tabindex="-1"><a class="header-anchor" href="#版本对比" aria-hidden="true">#</a> 版本对比</h2><h3 id="命令记录" tabindex="-1"><a class="header-anchor" href="#命令记录" aria-hidden="true">#</a> 命令记录</h3><p><code>git reflog</code></p><p>当关闭了界面后无法获得回退的快照ID，可用此方法查询操作和对应的版本快照</p><h3 id="git-diff" tabindex="-1"><a class="header-anchor" href="#git-diff" aria-hidden="true">#</a> git diff</h3><p>比较暂存区域和工作目录</p><p>--- a/README.md 旧文件 暂存区域 +++ b/README.md 新文件 工作目录</p><p>\\ No newline at end of file 文件不是以换行符结束</p><h3 id="linux命令" tabindex="-1"><a class="header-anchor" href="#linux命令" aria-hidden="true">#</a> LINUX命令</h3><p>h 帮助文档 q退出</p><p>j k 上下一行一行移动；d u 上下移动半页；f b 上下移动一页；g G 第一和最后一行；n g 第n行</p><p>/search ？search 搜索命令,高亮匹配</p><h3 id="对比两个快照的差异" tabindex="-1"><a class="header-anchor" href="#对比两个快照的差异" aria-hidden="true">#</a> 对比两个快照的差异</h3><p><code>git diff id1 id2</code></p><h3 id="比较当前工作目录和git仓库" tabindex="-1"><a class="header-anchor" href="#比较当前工作目录和git仓库" aria-hidden="true">#</a> 比较当前工作目录和Git仓库</h3><p><code>git diff id</code></p><h3 id="比较最新快照和当前目录" tabindex="-1"><a class="header-anchor" href="#比较最新快照和当前目录" aria-hidden="true">#</a> 比较最新快照和当前目录</h3><p><code>git diff HEAD</code></p><p><code>git diff HEAD -- readme.txt </code> 命令可以查看工作区和版本库里面最新版本的区别</p><h3 id="比较暂存区和git仓库" tabindex="-1"><a class="header-anchor" href="#比较暂存区和git仓库" aria-hidden="true">#</a> 比较暂存区和Git仓库</h3><p><code>git diff --cached</code></p><h3 id="比较暂存区和git仓库的快照id" tabindex="-1"><a class="header-anchor" href="#比较暂存区和git仓库的快照id" aria-hidden="true">#</a> 比较暂存区和Git仓库的快照ID</h3><p><code>git diff --cached [快照ID]</code></p><h2 id="小技巧" tabindex="-1"><a class="header-anchor" href="#小技巧" aria-hidden="true">#</a> 小技巧</h2><h3 id="_1-修改最后一次提交-amend" tabindex="-1"><a class="header-anchor" href="#_1-修改最后一次提交-amend" aria-hidden="true">#</a> 1.修改最后一次提交 --amend</h3><p>版本已提交，但是漏掉文件未添加add或者说明不完整</p><p><code>git commit --amend</code> 进入修改界面</p><p>i inset插入； 保存退出 需要先按 ESC，再打 <code>:wq</code> ； <code>:q!</code> 不修改直接退出</p><p>中文乱码解决： <code>:q!</code></p><p><code>git commit --amend -m &quot;新的说明&quot;</code></p><p>（m: 不进入提交说明页面）</p><h3 id="_2-删除文件-rm" tabindex="-1"><a class="header-anchor" href="#_2-删除文件-rm" aria-hidden="true">#</a> 2.删除文件 rm</h3><ul><li><p><code>git checkout -- file</code> 恢复工作目录删除的文件</p></li><li><p><code>git rm file</code> 删除已经commit的文件（git仓库还在，<strong>暂存区</strong>和<strong>工作目录</strong>删除）</p><p><code>git reset --soft HEAD~</code> 将Git仓库已提交的文件也删掉</p></li></ul><p><code>git rm 文件名</code> 该命令删除的只是工作目录和暂存区域的文件，也就是取消跟踪，在下次提交时不纳入版本管理</p><ul><li><p>当文件提交到暂存区<code>git add</code>但是工作目录又再次更改了文件（<code>git status</code>显示两种状态）</p><p>此时<code>git rm file</code>删除文件会报错，不知道删工作目录还是暂存区</p><p><code>git rm -f file</code> 将工作目录和暂存区都（force）删除</p><p><code>git rm --cached file</code> 只删除暂存区，保留工作目录文件</p></li></ul><h3 id="_3-重命名文件-mv" tabindex="-1"><a class="header-anchor" href="#_3-重命名文件-mv" aria-hidden="true">#</a> 3.重命名文件 mv</h3><p>文件改名：<code>git status</code> 提示删除旧文件，添加了为跟踪的新文件（改回原名恢复）</p><p>git mv 旧文件名 新文件名（三步）</p><ul><li>ren/mv 旧文件名 新文件名</li><li>git rm 旧文件名</li><li>git add新文件名</li></ul><h2 id="git分支" tabindex="-1"><a class="header-anchor" href="#git分支" aria-hidden="true">#</a> Git分支</h2><h3 id="创建分支-git-branch-name" tabindex="-1"><a class="header-anchor" href="#创建分支-git-branch-name" aria-hidden="true">#</a> 创建分支 git branch name</h3><ul><li>当前master分支和新name分支都指向一个快照，但是HEAD指向master</li><li>此时<code>git log --decorate</code> 显示内容（当前分支）</li><li><code>git log --decorate --oneline</code> 精简模式，一行显示一个快照</li></ul><h3 id="切换分支-git-checkout-name" tabindex="-1"><a class="header-anchor" href="#切换分支-git-checkout-name" aria-hidden="true">#</a> 切换分支 git checkout name</h3><ul><li>更改Repository（仓库）的HEAD指向的分支</li><li>在新分支更改commit后，<code>git log</code> 可查看到当前指向分支</li><li>此时<code>git checkout master</code> 本地的在新分支的更改回消失，变成master分支内容</li></ul><p><strong>相当于将master的最新快照还原到工作目录，HEAD指向master</strong></p><ul><li><code>git log --decorate --oneline --graph --all</code> all(查看所有分支状态图)</li></ul><h3 id="创建并切换分支" tabindex="-1"><a class="header-anchor" href="#创建并切换分支" aria-hidden="true">#</a> 创建并切换分支</h3><p><code>git checkout -b branch_name</code></p><h3 id="合并分支-git-merge" tabindex="-1"><a class="header-anchor" href="#合并分支-git-merge" aria-hidden="true">#</a> 合并分支 git merge</h3><p><code>git merge branch_name</code> 合并到主分支master，此时分支会消失，只剩下master</p><ul><li>当产生冲突时需要去修改冲突 <code>git add file</code>；<code>git commit -m &quot;fix conflict&quot;</code></li></ul><h3 id="删除分支-git-branch-d-name" tabindex="-1"><a class="header-anchor" href="#删除分支-git-branch-d-name" aria-hidden="true">#</a> 删除分支 git branch -d name</h3><p><code>git branch --delete name</code></p><p><code>git branch -d name</code></p><h4 id="删除未合并的分支" tabindex="-1"><a class="header-anchor" href="#删除未合并的分支" aria-hidden="true">#</a> 删除未合并的分支</h4><p>丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p><h3 id="fast-forward" tabindex="-1"><a class="header-anchor" href="#fast-forward" aria-hidden="true">#</a> Fast forward</h3><p>​ 通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>​ 如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>​ 准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code></p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>git merge --no-ff -m &quot;提交说明&quot; dev\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><ul><li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li></ul><h3 id="小结" tabindex="-1"><a class="header-anchor" href="#小结" aria-hidden="true">#</a> 小结</h3><p>查看分支：<code>git branch</code></p><p>创建分支：<code>git branch &lt;name&gt;</code></p><p>切换分支：<code>git checkout &lt;name&gt;</code></p><p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code></p><p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p><p>删除分支：<code>git branch -d &lt;name&gt;</code></p><h3 id="分支策略" tabindex="-1"><a class="header-anchor" href="#分支策略" aria-hidden="true">#</a> 分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</li><li>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</li><li>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</li></ul><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://raw.githubusercontent.com/caffreygo/static/main/blog/git/branch.png" alt="分支"></p><h3 id="分支储藏" tabindex="-1"><a class="header-anchor" href="#分支储藏" aria-hidden="true">#</a> 分支储藏</h3><p>当需要保存当前status : no clean分支状态(未add或者commit)去其它地方修复Bug时:</p><ul><li><code>git stash</code> 可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作</li></ul><p>(此时git status会变成clean)</p><ul><li><p>工作现场存到哪去了？用<code>git stash list</code>命令看看</p></li><li><p>可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git stash apply stash@{0}\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div></li></ul><h4 id="恢复stash" tabindex="-1"><a class="header-anchor" href="#恢复stash" aria-hidden="true">#</a> 恢复stash</h4><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了</p><p>(再用<code>git stash list</code>查看，就看不到任何stash内容了)</p><h3 id="匿名分支" tabindex="-1"><a class="header-anchor" href="#匿名分支" aria-hidden="true">#</a> 匿名分支</h3><p><code>git checkout HEAD~1</code> HEAD指向上一个快照，并创建一个匿名分支</p><p>（匿名分支所做的所有操作提交都会被丢弃）</p><p>在匿名分支修改提交<code>git checkout master</code></p><ul><li>git branch <code>new-branch-name</code> id 提醒方法创建分支并保存匿名分支的修改</li></ul><h3 id="git-checkout" tabindex="-1"><a class="header-anchor" href="#git-checkout" aria-hidden="true">#</a> git checkout</h3><p>1.从历史快照（或者暂存区）中拷贝文件到工作目录</p><p>2.切换分支</p><ul><li>git checkout --fileName（暂存区覆盖到工作目录）</li></ul><p>git checkout fileName也可以，但是可能出现分支名为fileName出现问题</p><ul><li>git checkout HEAD~fileName（将上一个快照的file文件复制到工作目录和暂存区）</li></ul><p>当给定某个文件名时，Git会从指定的提交中拷贝文件到暂存区和工作目录，比如执行</p><h3 id="恢复文件" tabindex="-1"><a class="header-anchor" href="#恢复文件" aria-hidden="true">#</a> 恢复文件</h3><ul><li>git reset fileName命令只将文件恢复到暂存区域（--mixed）</li></ul><p><code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区</p><p>（此时reset不允许使用--soft或者--hard）</p><ul><li>git checkout fileName命令同时覆盖暂存区域和工作目录</li><li>reset比checkout安全一些，不修改工作目录</li></ul><h3 id="恢复快照" tabindex="-1"><a class="header-anchor" href="#恢复快照" aria-hidden="true">#</a> 恢复快照</h3><p>​ <strong>reset</strong>用来回到过去，根据选项的不同，reset命令将移动HEAD指针(--soft)-&gt;覆盖暂存区(--mixed默认)，</p><p>-&gt;覆盖工作目录(--hard)</p><p>​ <strong>chekout</strong> 命令是用于切换分支，通过一定HEAD指针和覆盖暂存区域、工作目录实现</p><h3 id="reset和checkout的区别" tabindex="-1"><a class="header-anchor" href="#reset和checkout的区别" aria-hidden="true">#</a> reset和checkout的区别</h3><ul><li>checkout相比reset --hard更安全，checkout命令在切换分支之前会先检查一下当前的工作状态，如果不是clean的话，Git不会允许你这样做；而reset命令则是直接覆盖所有数据。</li><li>reset命令会移动HEAD所在分支的指向，而checkout命令只会移动HEAD自身来指向另一个分支</li></ul><p><code>git checkout feature</code> / <code>git reset --hard feature</code></p><p>git reset --hard feature会将整个分支回到过去，将HEAD指向的分支（master）和HEAD本身都切换到了feature，此时master分支原本做的修改会消失</p><ul><li>在master分支reset feature分支</li></ul><p><img src="https://raw.githubusercontent.com/caffreygo/static/main/blog/git/reset.png" alt=""></p><p>（master的修改6.txt消失）</p><ul><li><p>在feature查看log</p><p><img src="https://raw.githubusercontent.com/caffreygo/static/main/blog/git/checkout.png" alt=""></p></li></ul><h2 id="远程仓库" tabindex="-1"><a class="header-anchor" href="#远程仓库" aria-hidden="true">#</a> 远程仓库</h2><h3 id="添加远程库" tabindex="-1"><a class="header-anchor" href="#添加远程库" aria-hidden="true">#</a> 添加远程库</h3><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li></ul><p>（<code>git push origin master</code> 将本地master分支的内容提交到远程origin仓库）</p><h3 id="从远程库克隆" tabindex="-1"><a class="header-anchor" href="#从远程库克隆" aria-hidden="true">#</a> 从远程库克隆</h3><p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p><p>Git支持多种协议，包括<code>https</code>，但通过<code>ssh</code>支持的原生<code>git</code>协议速度最快。</p><h3 id="查看远程仓库信息" tabindex="-1"><a class="header-anchor" href="#查看远程仓库信息" aria-hidden="true">#</a> 查看远程仓库信息</h3><ul><li>查看远程库的信息，用<code>git remote</code></li><li>或者，用<code>git remote -v</code>显示更详细的信息</li></ul><h3 id="推送分支" tabindex="-1"><a class="header-anchor" href="#推送分支" aria-hidden="true">#</a> 推送分支</h3><p>​ 把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 ：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git push origin master\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git push origin dev\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="分支推送选择" tabindex="-1"><a class="header-anchor" href="#分支推送选择" aria-hidden="true">#</a> 分支推送选择</h4><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><h2 id="多人协作" tabindex="-1"><a class="header-anchor" href="#多人协作" aria-hidden="true">#</a> 多人协作</h2><p>多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h3 id="创建远程origin的dev分支到本地" tabindex="-1"><a class="header-anchor" href="#创建远程origin的dev分支到本地" aria-hidden="true">#</a> 创建远程<code>origin</code>的<code>dev</code>分支到本地</h3><p><code>git checkout -b dev origin/dev</code></p><p>分支推送 <code>git push origin dev</code></p><h3 id="冲突解决" tabindex="-1"><a class="header-anchor" href="#冲突解决" aria-hidden="true">#</a> 冲突解决</h3><p>先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送</p><h3 id="git-pull失败" tabindex="-1"><a class="header-anchor" href="#git-pull失败" aria-hidden="true">#</a> git pull失败</h3><p>例如在dev分支git pull提示：There is no tracking information for the current branch.</p><ul><li>原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接</li></ul><p><strong>解决</strong>：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git branch --set-upstream-to=origin/dev dev\n$ git pull\n解决冲突\n$ git commit -m &quot;fix conflict&quot;\n$ git push origin dev\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="小结-1" tabindex="-1"><a class="header-anchor" href="#小结-1" aria-hidden="true">#</a> 小结</h3><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><h3 id="rebase" tabindex="-1"><a class="header-anchor" href="#rebase" aria-hidden="true">#</a> Rebase</h3><p>把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p><p>可以git push之前整理分支提交历史</p><h2 id="标签管理" tabindex="-1"><a class="header-anchor" href="#标签管理" aria-hidden="true">#</a> 标签管理</h2><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的</p><h3 id="创建标签" tabindex="-1"><a class="header-anchor" href="#创建标签" aria-hidden="true">#</a> 创建标签</h3><p><code>git tag &lt;name&gt;</code>就可以打一个新标签</p><p>查看标签 <code>git tag</code></p><ul><li>对commit历史的某个提交打标签：</li></ul><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git log --pretty=oneline --abbrev-commit\n$ git tag v0.9 f52c633\n$ git tag\n$ git show v0.9\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="带有说明的标签" tabindex="-1"><a class="header-anchor" href="#带有说明的标签" aria-hidden="true">#</a> 带有说明的标签</h4><p>用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="小结-2" tabindex="-1"><a class="header-anchor" href="#小结-2" aria-hidden="true">#</a> 小结</h4><ul><li>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><h3 id="操作标签" tabindex="-1"><a class="header-anchor" href="#操作标签" aria-hidden="true">#</a> 操作标签</h3><h4 id="删除" tabindex="-1"><a class="header-anchor" href="#删除" aria-hidden="true">#</a> 删除</h4><p>​ <code>git tag -d v0.9</code></p><p>​ 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><h4 id="推送标签到远程" tabindex="-1"><a class="header-anchor" href="#推送标签到远程" aria-hidden="true">#</a> 推送标签到远程</h4><p>​ 使用命令 <code>push origin &lt;tagname&gt;</code> 推送某个标签</p><p>​ <code>git push origin --tags</code> 推送所有标签</p><h4 id="删除已推送标签" tabindex="-1"><a class="header-anchor" href="#删除已推送标签" aria-hidden="true">#</a> 删除已推送标签</h4><ol><li>删除本地标签： <code>git tag -d v0.9</code></li><li>删除远程标签：<code>git push origin :refs/tags/v0.9</code></li></ol><h4 id="小结-3" tabindex="-1"><a class="header-anchor" href="#小结-3" aria-hidden="true">#</a> 小结</h4><ul><li>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</li></ul>',222),d={render:function(e,i){return t}}}}]);