"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[5948],{1956:(e,n,a)=>{a.r(n),a.d(n,{data:()=>s});const s={key:"v-592ce6c2",path:"/tools/websocket.html",title:"WebSocket",lang:"zh-CN",frontmatter:{},excerpt:"",headers:[{level:2,title:"特点",slug:"特点",children:[{level:3,title:"全双工",slug:"全双工",children:[]},{level:3,title:"二进制帧",slug:"二进制帧",children:[]},{level:3,title:"协议名",slug:"协议名",children:[]},{level:3,title:"握手",slug:"握手",children:[]},{level:3,title:"优点",slug:"优点",children:[]}]},{level:2,title:"应用场景",slug:"应用场景",children:[]}],filePathRelative:"tools/websocket.md",git:{updatedTime:1662083776e3,contributors:[{name:"Jinrui Chen",email:"jinrui@kooboo.cn",commits:1}]}}},256:(e,n,a)=>{a.r(n),a.d(n,{default:()=>c});const s=(0,a(6252).uE)('<h1 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> WebSocket</h1><div class="custom-container tip"><p class="custom-container-title">WebSocket</p><p>一种网络传输协议，位于<code>OSI</code>模型的<strong>应用层</strong>。可在单个<code>TCP</code>连接上进行<strong>全双工</strong>通信，能更好的节省服务器资源和带宽并达到实时通迅。</p><p>客户端和服务器只需要完成<strong>一次握手</strong>，两者之间就可以创建持久性的连接，并进行双向数据传输。</p></div><blockquote><p>在<code>websocket</code>出现之前，开发实时<code>web</code>应用的方式为轮询。</p><p>不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果。</p><p>⚡️ 轮询的缺点也很明显，反复发送无效查询请求耗费了大量的带宽和 <code>CPU</code>资源。</p></blockquote><h2 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h2><h3 id="全双工" tabindex="-1"><a class="header-anchor" href="#全双工" aria-hidden="true">#</a> 全双工</h3><p>通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。</p><p>例如指 A→B 的同时 B→A ，是瞬时同步的。</p><h3 id="二进制帧" tabindex="-1"><a class="header-anchor" href="#二进制帧" aria-hidden="true">#</a> 二进制帧</h3><p>采用了二进制帧结构，语法、语义与 HTTP 完全不兼容，相比 <code>http/2</code> ，<code>WebSocket</code>更侧重于“实时通信”，而<code>HTTP/2</code> 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。</p><p>不像 <code>HTTP/2</code> 那样定义流，也就不存在多路复用、优先级等特性。</p><p>自身就是全双工，也不需要服务器推送。</p><h3 id="协议名" tabindex="-1"><a class="header-anchor" href="#协议名" aria-hidden="true">#</a> 协议名</h3><p>引入 <code>ws</code> 和 <code>wss</code> 分别代表明文和密文的 <code>websocket</code> 协议，且默认端口使用 80 或 443，几乎与 <code>http</code> 一致：</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code><span class="token header-name keyword">ws:</span>//www.chrono.com\n<span class="token header-name keyword">ws:</span>//www.chrono.com:8080/srv\n<span class="token header-name keyword">wss:</span>//www.chrono.com:445/im?user_id=xxx\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="握手" tabindex="-1"><a class="header-anchor" href="#握手" aria-hidden="true">#</a> 握手</h3><p><code>WebSocket</code>也要有一个握手过程，然后才能正式收发数据。客户端发送数据格式如下：</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code>GET ws://192.168.10.64:8080/sockjs-node/017/emx2b1pz/websocket HTTP/1.1\n<span class="token header-name keyword">Host:</span> 192.168.10.64:8080\n✅ Connection: Upgrade\n<span class="token header-name keyword">Pragma:</span> no-cache\n<span class="token header-name keyword">Cache-Control:</span> no-cache\n<span class="token header-name keyword">User-Agent:</span> Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/104.0.0.0 Safari/537.36\n✅ Upgrade: websocket\n<span class="token header-name keyword">Origin:</span> http://localhost:8080\n✅ Sec-WebSocket-Version: 13\n<span class="token header-name keyword">Accept-Encoding:</span> gzip, deflate\n<span class="token header-name keyword">Accept-Language:</span> en,zh;q=0.9,zh-CN;q=0.8\n✅ Sec-WebSocket-Key: 5OY3YDN4POGmZrcwSea+PQ==\n<span class="token header-name keyword">Sec-WebSocket-Extensions:</span> permessage-deflate; client_max_window_bits\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><ul><li><code>Connection</code>：必须设置 <code>Upgrade</code>，表示客户端希望<strong>连接升级</strong></li><li><code>Upgrade</code>：必须设置 <code>Websocket</code>，表示希望升级到 <code>Websocket</code> 协议</li><li><code>Sec-WebSocket-Key</code>：客户端发送的一个 base64 编码的密文，用于简单的认证秘钥。要求服务端必须返回一个对应加密的 <code>Sec-WebSocket-Accept</code> 应答，否则客户端会抛出错误，并关闭连接</li><li><code>Sec-WebSocket-Version</code> ：表示支持的 <code>Websocket</code> 版本</li></ul><p>服务端返回的数据格式：</p><div class="language-http ext-http line-numbers-mode"><pre class="language-http"><code>✅ HTTP/1.1 101 Switching Protocols\n<span class="token header-name keyword">Upgrade:</span> websocket\n<span class="token header-name keyword">Connection:</span> Upgrade\n✅ Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=Sec-WebSocket-Protocol: chat\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><code>HTTP/1.1 101 Switching Protocols</code>：表示服务端接受 <code>WebSocket</code> 协议的客户端连接。</li><li><code>Sec-WebSocket-Accep</code> ：验证客户端请求报文，同样也是为了防止误连接。具体做法是把请求头里 <code>Sec-WebSocket-Key</code> 的值，加上一个专用的 UUID，再计算摘要</li></ul><h3 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h3><ul><li>较少的控制开销：数据包头部协议较小，不同于http每次请求需要携带完整的头部</li><li>更强的实时性：相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少</li><li>保持创连接状态：创建通信后，可省略状态信息，不同于HTTP每次请求需要携带身份验证</li><li>更好的二进制支持：定义了二进制帧，更好处理二进制内容</li><li>支持扩展：用户可以扩展 <code>websocket</code> 协议、实现部分自定义的子协议</li><li>更好的压缩效果：<code>Websocket</code> 在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率</li></ul><h2 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h2><p>基于<code>websocket</code>的事实通信的特点，其存在的应用场景大概有：</p><ul><li>弹幕</li><li>媒体聊天</li><li>协同编辑</li><li>基于位置的应用</li><li>体育实况更新</li><li>股票基金报价实时更新</li></ul>',26),c={render:function(e,n){return s}}}}]);